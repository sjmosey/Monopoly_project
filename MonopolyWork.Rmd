---
title: "MonopolyWork"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
position<-1
money<-3000
properties<-0
p1<- data.frame(position, money, properties)
p2<- data.frame(position, money, properties)
p3<- data.frame(position, money, properties)
p4<- data.frame(position, money, properties)

#ultimately we will want to loop through take turn a number of times (at bottom)
takeTurn<-function(p)#function that includes all other functions that one player will go through for a turn, parameter is one player data frame
{
  isDone<-function(p) #function checks if player taking turn is out of money or not
    { 
	  if (p$money <= 0){
	  return()
	  }
  if(isDone(p)==FALSE){
 d<-0
roll<-function(x) #function to roll dice just using sampling twice
    {
    x<-sample(1:6,2,replace=TRUE)
      if(x[1]==x[2]){
        return(x) #right now if you roll doubles it will just print the pair and that's it
      }
    else{
      spaces=(x[1]+x[2]) #if you don't roll doubles the sum is printed
      getDesination<-function(pos, spaces) #function that gets the board position
            {
            	pos<-(pos + spaces) %% 40
            	return(pos)
            }
  p$position<-getDesination(p$position, spaces)
    }
  }
 roll(d)
 #  move<-function(p,pos){
 #     if(pos < p$position){
 #       p$money<-p$money+200 #player passed go and receives $200
 #     }
 #   else{
 #     p$postion<-pos
 #     #takeAction(p) - need to define function called takeAction() where the player moves
 #   }
 # }
 # move(p, newPos)
  }
  }
}

# for(i in 1){
#   takeTurn(p1)
#   takeTurn(p2)
#   takeTurn(p3)
#   takeTurn(p4)
#   
#   return(p1)
#   return(p2)
#   return(p3)
#   return(p4)
# }


takeTurn(p1)


#below is test code for part of the loop. I tested it on just p1. It works by rolling the dice and then updating the player position in the data frame. I need to get it to work in the larger loop though.  
p<-p1
d<-0
roll<-function(x) #function to roll dice just using sampling twice
    {
    x<-sample(1:6,2,replace=TRUE)
      if(x[1]==x[2]){
        return(x) #right now if you roll doubles it will just print the pair and that's it
      }
    else{
      spaces=(x[1]+x[2]) #if you don't roll doubles the sum is printed
      getDesination<-function(pos, dicesum) #function that gets the board position
            {
            	pos<-(pos + dicesum) %% 40
            	return(pos)
            }
  p1$position<-getDesination(p$position, spaces)
    }
    return(p1)
  }
 roll(d)
 
```

